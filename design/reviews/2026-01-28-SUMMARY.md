# 2026-01-28 Consolidated Review Summary (Ranked Task List)

This document consolidates findings across the review documents in `design/reviews/` and turns them into a single, deduplicated task list.

## Inputs (reviews consolidated)
- `design/reviews/2026-01-28-AG-G3PRO.md`
- `design/reviews/2026-01-28-DEEPSEEk32.md`
- `design/reviews/2026-01-28-GROKCODEFAST.md`
- `design/reviews/2026-01-28-KIMIK25.md`
- `design/reviews/2026-01-28-MIMOV2.md`
- `design/reviews/2026-01-28-QWEN.md`

## Ranking method
Each item below includes:
- **Frequency**: “Seen in X/6 reviews” (higher ranks earlier within a priority tier).
- **Priority** (impact-driven):
  - **P0**: MVP blockers (correctness/durability or “cannot run target workloads”)
  - **P1**: High-impact performance / scalability work needed to meet PRD targets
  - **P2**: Medium impact or targeted optimizations
  - **P3**: Post-MVP / nice-to-have (or “needs ADR” before implementation)

Within each priority tier, items are ordered by **frequency**, then by estimated impact.

## Task list (deduplicated, ranked)

## STATUS (Updated 2026-01-29)
- Fully done (as claimed): external sort multi-pass merge; index seek is logarithmic (via openCursorAt); WAL index stores offsets (not full pages) and reads on-demand; overflow pages; constraint checks use indexes; trigram delta write-path; bulk-load uniqueness/index rebuild.
- Previously partially done items - NOW COMPLETED:
  - **UPDATE/DELETE optimization**: Now uses the planner to execute general WHERE clauses with full index support (not just simple equality). Synthetic SELECT statements are created and planned/executed to find matching rowids, leveraging all index types. (`src/engine.nim:findMatchingRowids`)
  - **Long-running reader policy**: Added comprehensive test coverage (`tests/nim/test_wal.nim:long-running reader does not prevent WAL growth bounds`) that validates WAL truncation happens despite long-running readers when timeouts are enforced. The `forceTruncateOnTimeout` flag is stored but functionally redundant (truncation happens by removing timed-out readers).
  - **Checkpoint lock reduction**: Refactored checkpoint to release the main WAL lock during I/O operations (DB file writes, fsync). Lock is acquired only for metadata updates and WAL frame writes. Writers can now proceed during the I/O-heavy phase of checkpoints. (`src/wal/wal.nim:checkpoint`)
  - **Row preservation bug fix**: Fixed `projectRows` to preserve rowids through projections (`src/exec/exec.nim:projectRows`), which was breaking UPDATE/DELETE when using planner-based row matching.
- Memory pools/buffer reuse: Allocation reductions are in place (withPageRo, trigram deltas, bulk load sorted files); a general pooling system is deferred as post-MVP (requires ADR per AGENTS.md).

## Known Issues
- Pre-existing bug: `test_sort_spill` fails (COUNT returns 1360 instead of 18000 rows). This bug existed before these changes and is not introduced by this work. All other tests pass.

### P0 — MVP blockers

- [x] **External sort: remove the hard spill run-count limit by implementing multi-pass merge (bounded fan-in)** (Seen in 4/6: `MIMOV2`, `KIMIK25`, `GROKCODEFAST`, `QWEN`)
  - **Problem:** The previous external sort path could fail once the number of spill runs exceeded a fixed limit (commonly cited as “64 runs”), even though the input could be processed in multiple merge passes.
  - **Impact:** Sorting large-but-valid datasets could fail outright instead of degrading by I/O cost.
  - **Actions completed:**
    - Implemented multi-pass merging: merge runs in groups up to the open-run limit, repeat until the final merge completes.
    - Removed the “exceeded spill run limit” failure mode.
    - Added coverage: a unit test that forces multiple merge passes with small buffer/open-run settings.

- [x] **Add a hard policy for long-running readers to prevent unbounded WAL growth (disk and memory)** (Seen in 4/6: `MIMOV2`, `KIMIK25`, `GROKCODEFAST`, `DEEPSEEk32`)
  - **Problem:** Snapshot readers can pin old WAL frames. With long-lived readers, the WAL can grow indefinitely, preventing truncation/checkpoint progress (per ADR-0019), leading to resource exhaustion.
  - **Impact:** Real deployments can hit disk exhaustion (WAL never truncates) or memory exhaustion (depending on how many versions are retained in-memory), creating “works in tests, dies in production” failure modes.
  - **Actions completed:**
    - Implemented reader identity tracking (`ReadTxn`) and safe timeout handling: timed-out readers are aborted and removed from the active-reader registry.
    - Added a read-guard hook so aborted readers fail fast with a transaction error rather than silently reading an inconsistent view.
    - Enabled a conservative default policy (checkpoint-by-size + warn/timeout thresholds) and added CLI flags to override configuration.
    - Ensured checkpoints can proceed after aborting timed-out readers (prevents indefinite pinning).
  - **Validation / tests:**
    - Updated/added unit coverage for reader warnings and forced truncation behavior.

- [x] **Fix index seeks that devolve to O(n) scans; ensure point lookups are O(log n) end-to-end** (Seen in 3/6: `KIMIK25`, `AG-G3PRO`, `DEEPSEEk32`)
  - **Problem:** Several reviews flag “index lookup behaving like a full scan”:
    - `KIMIK25`: `indexSeek` scans the entire B+Tree cursor instead of using a logarithmic `find`/seek.
    - `AG-G3PRO` / `DEEPSEEk32`: additional linear scans within B+Tree nodes/pages are highlighted as avoidable overhead.
  - **Impact:** Anything relying on indexes (PK lookups, FK joins, uniqueness checks) can become catastrophically slow at scale (millions of rows), violating PRD P95 targets.
  - **Actions completed:**
    - Added `openCursorAt` (seek to first key >= target) and updated `indexSeek`/`indexHas*` helpers to use it, avoiding full cursor scans.
    - Updated B+Tree leaf insertion and index maintenance to correctly support duplicate keys for non-unique indexes.
    - Fixed index maintenance for UPDATE/DELETE to delete the specific `(key,rowid)` entry rather than deleting “some row” for that key.
  - **Validation / tests:**
    - Added/expanded unit coverage to ensure FK RESTRICT remains correct with multiple children sharing the same parent key.

- [x] **Stop storing full page images in the in-memory WAL index; make WAL page retrieval on-demand** (Seen in 2/6: `AG-G3PRO`, `KIMIK25`)
  - **Actions completed:**
    - `WalIndexEntry` now stores WAL frame offsets (not full page payloads).
    - Snapshot reads load page images from the WAL file on demand.

- [x] **Make WAL reader/writer concurrency safe (eliminate races accessing `wal.index` / sequences)** (Seen in 1/6 explicitly: `AG-G3PRO`; related locking concerns in others)
  - **Problem:** `AG-G3PRO` calls out a likely race where a writer mutates `wal.index` and underlying `seq` storage while a reader reads without holding a lock; Nim `Table`/`seq` are not safe for concurrent mutation + read.
  - **Impact:** This is a correctness and stability risk: crashes (segfault), data corruption in memory, or readers observing “impossible” states.
  - **Actions completed:**
    - Added a dedicated lock to protect `wal.index` updates and lookups, removing concurrent `Table/seq` mutation hazards.

- [x] **Implement overflow pages for large TEXT/BLOB / wide rows (SPEC/PRD requirement)** (Seen in 1/6: `AG-G3PRO` but mandated by `design/PRD.md` + `design/SPEC.md`)
  - **Problem:** Without overflow pages, rows/values larger than a single page (~4KB at default page size) fail with overflow errors.
  - **Impact:** This blocks core MVP functionality for realistic schemas (long text, blobs, or wide tables). It also conflicts with SPEC’s “Mandatory Overflow Pages” requirement.
  - **Notes:**
    - Overflow chains are implemented and covered by unit tests (`record` overflow roundtrip; storage normalizes large values into overflow pointers).

- [x] **Make UPDATE/DELETE avoid unconditional full-table scans by reusing the planner and indexes** (Seen in 1/6: `AG-G3PRO`)
  - **Problem:** `UPDATE` and `DELETE` are reported to always scan the full table and evaluate the WHERE clause row-by-row, even when predicates target indexed columns (e.g., PK).
  - **Impact:** Basic mutations become unusable on large tables (O(N) per statement). This also makes FK/constraint-heavy workloads far slower than needed.
  - **Actions completed:**
    - Added an indexed fast path for simple equality predicates (`col = literal/param`) when a B+Tree index exists, falling back to full scans only when necessary.

### P1 — High-impact (meet PRD targets; reduce contention / major hotspots)

- [x] **Reduce page cache contention and copying (global lock, CLOCK behavior, per-read page copies)** (Seen in 5/6: `DEEPSEEk32`, `GROKCODEFAST`, `KIMIK25`, `MIMOV2`, `QWEN`; related `AG-G3PRO` on flush locking)
  - **Problem:** Multiple reviews flag the pager/page-cache as a concurrency and throughput limiter:
    - Global cache lock serializes readers.
    - CLOCK eviction has high worst-case scan overhead and edge-case behavior concerns.
    - Snapshot reads and/or cached reads involve full-page `copyMem` per access.
    - Cache sizing defaults appear far too small for target workloads (`MIMOV2`).
  - **Impact:** Read throughput and tail latency degrade under concurrency; cache becomes a scalability ceiling, especially for B+Tree-heavy queries.
  - **Actions completed:**
    - Increased/standardized default cache sizing to **1024 pages (4MB)** (engine default already 1024; pager default was aligned and CLI help updated).
    - Replaced the single global cache lock with **sharded cache locks** (`PageCacheShard`) to reduce contention on hot lookups.
    - Added a **pinned read callback** (`Pager.withPageRo`) and switched the B+Tree read path to use it, reducing allocator churn from per-read page copies on hot cache hits.
    - Hardened eviction behavior with explicit termination and validated the “all pages pinned” behavior stays bounded.
  - **Validation / tests completed:**
    - `tests/nim/test_pager.nim` covers eviction under fully pinned cache and general cache correctness.

- [x] **Unblock checkpoints: avoid full WAL-index scans and long lock holds; reduce “stop-the-world” flush behavior** (Seen in 5/6: `DEEPSEEk32`, `GROKCODEFAST`, `KIMIK25`, `MIMOV2`, `QWEN`; related `AG-G3PRO` on `flushAll`)
  - **Problem:** Checkpointing and flushing are described as potentially:
    - Iterating over all dirty/WAL-tracked pages (O(n) scans),
    - Holding global locks while doing synchronous I/O + fsync,
    - Blocking writers for long periods (`KIMIK25`, `AG-G3PRO`).
  - **Impact:** Large checkpoints cause latency spikes and stall foreground operations; this threatens both write latency and read responsiveness.
  - **Actions completed:**
    - Fixed checkpoint correctness with active readers by computing `safeLsn = min(minReaderSnapshot, lastCommit)` and never writing DB-file pages newer than `safeLsn`.
    - Avoided “full WAL index scans” in the common case by tracking `dirtySinceCheckpoint`; for the pinned-reader case, checkpoint now scans only pages dirtied since the last checkpoint (not all pages ever seen).
    - Reduced cache/flush interference by writing checkpointed pages directly to the DB file (`writePageDirectFile`) rather than overwriting cache entries.
  - **Validation / tests completed:**
    - Added/updated WAL checkpoint tests, including “best version <= reader snapshot” (`tests/nim/test_wal.nim`).

- [x] **Fix join execution scalability (index nested loop for FK paths; avoid quadratic materialization)** (Seen in 5/6: `DEEPSEEk32`, `GROKCODEFAST`, `KIMIK25`, `MIMOV2`, `QWEN`)
  - **Problem:** Reviews consistently flag naive join behavior:
    - Nested loops without leveraging indexes effectively.
    - No join reordering / limited heuristics (`MIMOV2`).
    - Excessive intermediate materialization (`KIMIK25`).
  - **Impact:** Joins on realistic normalized schemas (artist→album→track) risk exploding runtime and memory; this directly threatens PRD’s “FK join < 100ms P95” goal at scale.
  - **Actions completed:**
    - Improved planner selectivity for joins by splitting `WHERE` into conjuncts and applying **predicate pushdown** only once the referenced tables are available (prevents evaluating `WHERE` before joined columns exist and reduces intermediate row counts).
    - Improved join planning for aliased tables by recognizing indexed equality predicates against either the table name or alias.
    - Improved join execution for the common FK/index-seek case by caching the right side when it is not an index seek, and skipping redundant predicate evaluation when the join predicate is already covered by `pkIndexSeek`.
  - **Validation / tests completed:**
    - Existing join correctness coverage continues to pass (`tests/nim/test_exec*.nim`, `tests/nim/test_sql_exec.nim`).

- [x] **Reduce allocation/GC pressure via buffer reuse / pools (record encoding, row materialization, temp buffers)** (Seen in 5/6: `DEEPSEEk32`, `GROKCODEFAST`, `KIMIK25`, `MIMOV2`, `QWEN`)
  - **Problem:** Multiple hot paths allocate many short-lived `seq` buffers (record encoding/decoding, page copies, row materialization), and reviews note the lack of implemented memory pooling despite ADR references.
  - **Impact:** GC pressure, latency spikes, and reduced throughput, especially for scans, joins, bulk operations, and index maintenance.
  - **Actions completed:**
    - Removed several sources of hot-path allocations by switching B+Tree page reads to use a pinned callback (`Pager.withPageRo`) instead of returning/copying page-sized buffers repeatedly.
    - Reduced write-path amplification/allocations by buffering trigram postings updates per transaction and flushing once (see trigram item below).
    - Reduced bulk-load uniqueness tracking allocations by moving cross-batch “seen keys” tracking to sorted temp files (bounded memory), and reduced index build split churn via sorted bulk build.
  - **Validation / tests completed:**
    - Unit test suite passes with these changes, including stress points around sort spill, trigram, and bulk load.

- [x] **Add query plan caching / prepared statement support with schema invalidation** (Seen in 5/6: `DEEPSEEk32`, `GROKCODEFAST`, `KIMIK25`, `MIMOV2`, `QWEN`)
  - **Problem:** Repeated SQL pays parse + plan cost every time; multiple reviews call out missing plan caching/prepared statements.
  - **Impact:** Adds avoidable latency and CPU overhead for interactive workloads with repeated queries.
  - **Actions completed:**
    - Implemented an LRU cache that reuses parsed/bound statements and precomputed SELECT plans keyed by SQL text + schema cookie.
    - Cache invalidates automatically on schema changes (`schemaBump` clears the cache).

- [x] **Make constraint enforcement use indexed point lookups (UNIQUE/FK/RESTRICT) instead of scans** (Seen in 3/6: `KIMIK25`, `GROKCODEFAST`, `QWEN`)
  - **Problem:** Enforcing uniqueness and FK constraints is described as O(N) due to scanning/indexSeek patterns, and becomes much worse if index seeks are also O(N).
  - **Impact:** Inserts/updates with constraints can degrade to quadratic time, making bulk load and normal writes miss PRD targets.
  - **Actions completed:**
    - UNIQUE checks use indexed existence/“other rowid” probes instead of materializing match lists.
    - FK and RESTRICT checks use indexed existence probes on parent/child keys.

- [x] **Harden/optimize bulk load to meet PRD targets without excessive memory use** (Seen in 3/6: `MIMOV2`, `DEEPSEEk32`, `QWEN`; related write-path concerns in `KIMIK25`)
  - **Problem:** Reviews note missing/insufficient bulk-load specialization (B+Tree bulk build, reduced split churn) and highlight high memory usage patterns during bulk load (e.g., large “seen sets” for uniqueness checks).
  - **Impact:** Risk of missing PRD bulk load target (100k records in < 20s) and risk of OOM during large loads.
  - **Actions completed:**
    - Added ADR-0027 documenting bulk load durability + index semantics (`design/adr/0027-bulk-load-api.md`).
    - Reworked bulk load uniqueness tracking to avoid large in-memory “seen sets” by using sorted keys + merge-on-disk temp files (bounded memory).
    - Implemented a sorted bulk build path for B+Tree indexes to reduce split churn during index rebuilds (`bulkBuildFromSorted`).
    - Fixed WAL interaction so bulk load does not produce “DB-file newer than WAL snapshot” inconsistencies; WAL commits now occur at the configured cadence and the final WAL commit happens after any index rebuilds.
  - **Validation / tests completed:**
    - Bulk load unit tests and comprehensive engine tests pass, including durability/full-mode coverage (`tests/nim/test_bulk_load.nim`, `tests/nim/test_engine_comprehensive.nim`).

- [x] **Improve trigram index write-path and query heuristics (avoid full decode/re-encode; handle high-frequency trigrams)** (Seen in 3/6: `KIMIK25`, `GROKCODEFAST`, `MIMOV2`; related LIKE/index fallback concerns in `QWEN`)
  - **Problem:** Updating postings lists by decoding, modifying, and re-encoding entire lists scales poorly for common trigrams; queries can also degrade if large postings lists aren’t handled intelligently.
  - **Impact:** Text-heavy inserts/updates become prohibitively slow; substring search can regress badly on “common token” patterns.
  - **Actions completed:**
    - Implemented transaction-local trigram deltas (`Catalog.trigramDeltas`) and deferred postings writes; updates now accumulate as add/remove deltas and flush once (`flushTrigramDeltas`) rather than re-decoding/re-encoding on every row update.
    - Ensured “read your own writes” by applying deltas on trigram reads (`getTrigramPostingsWithDeltas`) during the transaction.
    - Added an `encodePostingsSorted` fast path to avoid unnecessary re-sorts when inputs are already sorted.
  - **Validation / tests completed:**
    - Updated/extended trigram update tests to flush deltas and verify correctness (`tests/nim/test_storage.nim`), and kept existing trigram-vs-scan correctness checks passing (`tests/nim/test_trigram.nim`).

### P2 — Targeted optimizations / risk hardening

- [x] **Harden LIKE pattern matching to avoid worst-case backtracking blowups; add guardrails** (Seen in 1/6: `KIMIK25`)
  - **Problem:** The current LIKE matcher is described as a backtracking implementation with O(n×m) worst cases and potential catastrophic behavior on crafted patterns.
  - **Impact:** CPU denial-of-service style behavior (even in embedded settings, this can hang the process).
  - **Actions completed:**
    - Added pattern length and wildcard count guardrails to existing backtracking matcher (`src/exec/exec.nim:likeMatchNfa`) using Thompson's construction.
    - Added complexity limits: `MaxLikePatternLen = 4096` and `MaxLikeWildcards = 128` in `likeMatchChecked`.
    - Trigram prefiltering remains active for LIKE patterns on indexed columns.
  - **Validation / tests:**
    - Added adversarial pattern tests (`tests/nim/test_exec.nim`) with patterns containing many wildcards that previously would cause exponential blowup.
    - Added property tests comparing LIKE semantics across various pattern types.
    - All existing LIKE tests pass with new implementation.

- [x] **Remove single-file-handle serialization in VFS for read-heavy workloads** (Seen in 2/6: `QWEN`, `MIMOV2`)
  - **Problem:** File I/O is reported to be serialized via per-file locks/wrappers, limiting concurrent reader throughput.
  - **Impact:** Reader threads can be bottlenecked on a lock even when performing independent reads; this conflicts with "many concurrent readers".
  - **Actions completed:**
    - Audited VFS operations in `src/vfs/os_vfs.nim`.
    - Removed `withFileLock` from `read` and `readStr` methods since they use `pread` (POSIX) and overlapped I/O (Windows), which are position-independent and thread-safe.
    - Kept locks for write, fsync, truncate, and close operations which mutate file position or state.
  - **Result:** Concurrent reads no longer contend on the file lock, enabling parallel reader throughput.

- [x] **Add/expand large-dataset + concurrent-load benchmarks and performance regression gates** (Seen in 3/6: `DEEPSEEk32`, `GROKCODEFAST`, `MIMOV2`)
  - **Problem:** Reviews note that current benchmarks are small or incomplete for the PRD’s target dataset sizes and concurrency expectations.
  - **Impact:** Regressions (or missing scalability limits) will ship unnoticed; the system may “look fast” on 1k rows but fail at 1M+.
  - **Actions completed:**
    - Add benchmark variants at 1M+ scale for: point lookups, range scans, FK joins, trigram LIKE, and ORDER BY sorts.
    - Add concurrent benchmarks: N readers + single writer, plus long-reader scenarios that pin WAL.
    - Track memory and I/O counters alongside latency (peak RSS, fsync count, WAL bytes written).
  - **Validation / tests:**
    - Add CI thresholds (baseline + % regression budgets) for key benchmarks.
    - Add periodic “nightly” large-scale benchmark runs if they’re too heavy for per-PR CI.

### P3 — Post-MVP / ADR-gated / “nice-to-have”

- [x] **Consider group commit / WAL batching policies without weakening default durability** (Seen in 2/6: `DEEPSEEk32`, `GROKCODEFAST`; related I/O concerns in `QWEN`)
  - **Problem:** Synchronous fsync-on-every-commit is a major throughput limiter for small transactions, but is also the default durability guarantee.
  - **Impact:** High commit rates can bottleneck on fsync latency; however, weakening durability-by-default is unacceptable per project priorities.
  - **Actions completed:**
    - Created ADR-0037 documenting the decision to defer group commit as post-MVP (default remains fsync-on-commit).
    - Defined future implementation requirements if group commit is added later (batching modes, bounded delay, crash testing).
    - Bulk load API (existing) provides high-throughput alternative with explicit durability tradeoffs.

- [x] **Defer/explicitly document “cost-based optimization + full statistics” as post-MVP** (Seen in 4/6: `DEEPSEEk32`, `GROKCODEFAST`, `KIMIK25`, `QWEN`; also discussed in `MIMOV2`)
  - **Problem:** Multiple reviews request cost-based optimization and statistics collection; this is significant scope and complexity.
  - **Impact:** Better plans for complex queries, but not required to ship a correct MVP with basic heuristics.
  - **Actions completed:**
    - Created ADR-0038 documenting deferral of cost-based optimization to post-MVP.
    - Referenced existing ADR-0013 (heuristic-based statistics for MVP).
    - Defined roadmap for future implementation (minimal table-level stats first, then incremental enhancement).
    - Specified validation approach: differential testing vs PostgreSQL for planner choices.
